ç®¡ç† ThreadPoolTaskExecutor çš„å…³é”®è¦ç‚¹
ä¿å­˜ Future å¯¹è±¡ - æäº¤ä»»åŠ¡æ—¶è¿”å›çš„ Future å¯ä»¥ç”¨æ¥å–æ¶ˆä»»åŠ¡
ä½¿ç”¨å¯ä¸­æ–­çš„ä»»åŠ¡ - ä»»åŠ¡å†…éƒ¨éœ€è¦æ£€æŸ¥ä¸­æ–­æ ‡å¿—
ä»»åŠ¡çŠ¶æ€è·Ÿè¸ª - ç»´æŠ¤ä»»åŠ¡çš„æ‰§è¡ŒçŠ¶æ€
ä¼˜é›…å…³é—­ - æ­£ç¡®å…³é—­çº¿ç¨‹æ± 
è®©æˆ‘ä¸ºä½ åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„ä»»åŠ¡ç®¡ç†å™¨ç¤ºä¾‹ï¼š
TaskManager.java(new)
package com.dataloader.task;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.stereotype.Component;

import javax.annotation.PreDestroy;
import java.util.Map;
import java.util.concurrent.*;

/**
 * ä»»åŠ¡ç®¡ç†å™¨ - ç®¡ç† ThreadPoolTaskExecutor ä¸­çš„ä»»åŠ¡
 * æ”¯æŒä»»åŠ¡çš„å¯åŠ¨ã€åœæ­¢ã€çŠ¶æ€æŸ¥è¯¢ç­‰åŠŸèƒ½
 */
@Component
public class TaskManager {
    
    private static final Logger logger = LoggerFactory.getLogger(TaskManager.class);
    
    private final ThreadPoolTaskExecutor taskExecutor;
    
    // ä¿å­˜ä»»åŠ¡IDå’Œå¯¹åº”çš„Futureå¯¹è±¡ï¼Œç”¨äºæ§åˆ¶ä»»åŠ¡
    private final Map<String, Future<?>> taskFutures = new ConcurrentHashMap<>();
    
    // ä¿å­˜ä»»åŠ¡çš„çŠ¶æ€ä¿¡æ¯
    private final Map<String, TaskInfo> taskInfoMap = new ConcurrentHashMap<>();
    
    public TaskManager() {
        this.taskExecutor = createTaskExecutor();
    }
    
    /**
     * åˆ›å»ºå’Œé…ç½®çº¿ç¨‹æ± 
     */
    private ThreadPoolTaskExecutor createTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        
        // æ ¸å¿ƒçº¿ç¨‹æ•°
        executor.setCorePoolSize(5);
        
        // æœ€å¤§çº¿ç¨‹æ•°
        executor.setMaxPoolSize(10);
        
        // é˜Ÿåˆ—å®¹é‡
        executor.setQueueCapacity(100);
        
        // çº¿ç¨‹åç§°å‰ç¼€
        executor.setThreadNamePrefix("ETL-Task-");
        
        // æ‹’ç»ç­–ç•¥ï¼šç”±è°ƒç”¨çº¿ç¨‹æ‰§è¡Œ
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        
        // çº¿ç¨‹ç©ºé—²æ—¶é—´ï¼ˆç§’ï¼‰
        executor.setKeepAliveSeconds(60);
        
        // å…è®¸æ ¸å¿ƒçº¿ç¨‹è¶…æ—¶
        executor.setAllowCoreThreadTimeOut(true);
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆåå†å…³é—­çº¿ç¨‹æ± 
        executor.setWaitForTasksToCompleteOnShutdown(true);
        
        // ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰
        executor.setAwaitTerminationSeconds(60);
        
        // åˆå§‹åŒ–
        executor.initialize();
        
        logger.info("çº¿ç¨‹æ± åˆå§‹åŒ–å®Œæˆ: corePoolSize={}, maxPoolSize={}, queueCapacity={}", 
                    executor.getCorePoolSize(), executor.getMaxPoolSize(), executor.getQueueCapacity());
        
        return executor;
    }
    
    /**
     * æäº¤ä¸€ä¸ªä»»åŠ¡
     * @param taskId ä»»åŠ¡IDï¼ˆå”¯ä¸€æ ‡è¯†ï¼‰
     * @param task ä»»åŠ¡å¯¹è±¡
     * @return æ˜¯å¦æäº¤æˆåŠŸ
     */
    public boolean submitTask(String taskId, Runnable task) {
        if (taskFutures.containsKey(taskId)) {
            logger.warn("ä»»åŠ¡å·²å­˜åœ¨: {}", taskId);
            return false;
        }
        
        try {
            // åŒ…è£…ä»»åŠ¡ï¼Œæ·»åŠ çŠ¶æ€ç®¡ç†
            ManagedTask managedTask = new ManagedTask(taskId, task);
            
            // æäº¤ä»»åŠ¡å¹¶ä¿å­˜Future
            Future<?> future = taskExecutor.submit(managedTask);
            taskFutures.put(taskId, future);
            
            // è®°å½•ä»»åŠ¡ä¿¡æ¯
            TaskInfo taskInfo = new TaskInfo(taskId, TaskStatus.RUNNING);
            taskInfoMap.put(taskId, taskInfo);
            
            logger.info("ä»»åŠ¡å·²æäº¤: taskId={}, å½“å‰æ´»è·ƒä»»åŠ¡æ•°={}", taskId, taskExecutor.getActiveCount());
            return true;
            
        } catch (Exception e) {
            logger.error("æäº¤ä»»åŠ¡å¤±è´¥: taskId={}", taskId, e);
            return false;
        }
    }
    
    /**
     * æäº¤ä¸€ä¸ªCallableä»»åŠ¡ï¼ˆå¯ä»¥è¿”å›ç»“æœï¼‰
     */
    public <T> Future<T> submitTask(String taskId, Callable<T> task) {
        if (taskFutures.containsKey(taskId)) {
            logger.warn("ä»»åŠ¡å·²å­˜åœ¨: {}", taskId);
            return null;
        }
        
        try {
            // åŒ…è£…ä»»åŠ¡
            ManagedCallableTask<T> managedTask = new ManagedCallableTask<>(taskId, task);
            
            // æäº¤ä»»åŠ¡
            Future<T> future = taskExecutor.submit(managedTask);
            taskFutures.put(taskId, future);
            
            // è®°å½•ä»»åŠ¡ä¿¡æ¯
            TaskInfo taskInfo = new TaskInfo(taskId, TaskStatus.RUNNING);
            taskInfoMap.put(taskId, taskInfo);
            
            logger.info("Callableä»»åŠ¡å·²æäº¤: taskId={}", taskId);
            return future;
            
        } catch (Exception e) {
            logger.error("æäº¤Callableä»»åŠ¡å¤±è´¥: taskId={}", taskId, e);
            return null;
        }
    }
    
    /**
     * åœæ­¢æŒ‡å®šä»»åŠ¡
     * @param taskId ä»»åŠ¡ID
     * @param mayInterruptIfRunning æ˜¯å¦ä¸­æ–­æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡
     * @return æ˜¯å¦æˆåŠŸåœæ­¢
     */
    public boolean stopTask(String taskId, boolean mayInterruptIfRunning) {
        Future<?> future = taskFutures.get(taskId);
        
        if (future == null) {
            logger.warn("ä»»åŠ¡ä¸å­˜åœ¨: {}", taskId);
            return false;
        }
        
        if (future.isDone()) {
            logger.info("ä»»åŠ¡å·²å®Œæˆï¼Œæ— éœ€åœæ­¢: {}", taskId);
            taskFutures.remove(taskId);
            updateTaskStatus(taskId, TaskStatus.COMPLETED);
            return true;
        }
        
        try {
            // å–æ¶ˆä»»åŠ¡
            boolean cancelled = future.cancel(mayInterruptIfRunning);
            
            if (cancelled) {
                logger.info("ä»»åŠ¡å·²åœæ­¢: taskId={}, interrupt={}", taskId, mayInterruptIfRunning);
                taskFutures.remove(taskId);
                updateTaskStatus(taskId, TaskStatus.CANCELLED);
            } else {
                logger.warn("ä»»åŠ¡åœæ­¢å¤±è´¥: {}", taskId);
            }
            
            return cancelled;
            
        } catch (Exception e) {
            logger.error("åœæ­¢ä»»åŠ¡å¼‚å¸¸: taskId={}", taskId, e);
            return false;
        }
    }
    
    /**
     * åœæ­¢æ‰€æœ‰ä»»åŠ¡
     */
    public void stopAllTasks(boolean mayInterruptIfRunning) {
        logger.info("å¼€å§‹åœæ­¢æ‰€æœ‰ä»»åŠ¡, å½“å‰ä»»åŠ¡æ•°: {}", taskFutures.size());
        
        taskFutures.keySet().forEach(taskId -> stopTask(taskId, mayInterruptIfRunning));
        
        logger.info("æ‰€æœ‰ä»»åŠ¡å·²åœæ­¢");
    }
    
    /**
     * è·å–ä»»åŠ¡çŠ¶æ€
     */
    public TaskStatus getTaskStatus(String taskId) {
        TaskInfo taskInfo = taskInfoMap.get(taskId);
        
        if (taskInfo == null) {
            return TaskStatus.NOT_FOUND;
        }
        
        Future<?> future = taskFutures.get(taskId);
        
        if (future == null) {
            return taskInfo.getStatus();
        }
        
        if (future.isDone()) {
            if (future.isCancelled()) {
                updateTaskStatus(taskId, TaskStatus.CANCELLED);
            } else {
                updateTaskStatus(taskId, TaskStatus.COMPLETED);
            }
        }
        
        return taskInfo.getStatus();
    }
    
    /**
     * è·å–ä»»åŠ¡ä¿¡æ¯
     */
    public TaskInfo getTaskInfo(String taskId) {
        TaskInfo taskInfo = taskInfoMap.get(taskId);
        if (taskInfo != null) {
            // æ›´æ–°çŠ¶æ€
            getTaskStatus(taskId);
        }
        return taskInfo;
    }
    
    /**
     * è·å–æ‰€æœ‰ä»»åŠ¡ä¿¡æ¯
     */
    public Map<String, TaskInfo> getAllTaskInfo() {
        // æ›´æ–°æ‰€æœ‰ä»»åŠ¡çš„çŠ¶æ€
        taskInfoMap.keySet().forEach(this::getTaskStatus);
        return new ConcurrentHashMap<>(taskInfoMap);
    }
    
    /**
     * è·å–çº¿ç¨‹æ± çŠ¶æ€
     */
    public ThreadPoolStatus getThreadPoolStatus() {
        ThreadPoolExecutor executor = taskExecutor.getThreadPoolExecutor();
        
        return new ThreadPoolStatus(
            executor.getPoolSize(),           // å½“å‰çº¿ç¨‹æ± å¤§å°
            executor.getActiveCount(),        // æ´»è·ƒçº¿ç¨‹æ•°
            executor.getCompletedTaskCount(), // å·²å®Œæˆä»»åŠ¡æ•°
            executor.getTaskCount(),          // æ€»ä»»åŠ¡æ•°
            executor.getQueue().size()        // é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡æ•°
        );
    }
    
    /**
     * æ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡è®°å½•
     */
    public void cleanupCompletedTasks() {
        taskFutures.entrySet().removeIf(entry -> {
            Future<?> future = entry.getValue();
            if (future.isDone()) {
                String taskId = entry.getKey();
                logger.debug("æ¸…ç†å·²å®Œæˆä»»åŠ¡: {}", taskId);
                return true;
            }
            return false;
        });
    }
    
    /**
     * æ›´æ–°ä»»åŠ¡çŠ¶æ€
     */
    private void updateTaskStatus(String taskId, TaskStatus status) {
        TaskInfo taskInfo = taskInfoMap.get(taskId);
        if (taskInfo != null) {
            taskInfo.setStatus(status);
            if (status == TaskStatus.COMPLETED || status == TaskStatus.CANCELLED || status == TaskStatus.FAILED) {
                taskInfo.setEndTime(System.currentTimeMillis());
            }
        }
    }
    
    /**
     * åº”ç”¨å…³é—­æ—¶ä¼˜é›…å…³é—­çº¿ç¨‹æ± 
     */
    @PreDestroy
    public void shutdown() {
        logger.info("å¼€å§‹å…³é—­çº¿ç¨‹æ± ...");
        
        try {
            // åœæ­¢æ‰€æœ‰ä»»åŠ¡
            stopAllTasks(true);
            
            // å…³é—­çº¿ç¨‹æ± 
            taskExecutor.shutdown();
            
            // ç­‰å¾…ä»»åŠ¡å®Œæˆ
            if (!taskExecutor.getThreadPoolExecutor().awaitTermination(60, TimeUnit.SECONDS)) {
                logger.warn("çº¿ç¨‹æ± æœªåœ¨æŒ‡å®šæ—¶é—´å†…å®Œæˆï¼Œå¼ºåˆ¶å…³é—­");
                taskExecutor.getThreadPoolExecutor().shutdownNow();
            }
            
            logger.info("çº¿ç¨‹æ± å·²å…³é—­");
            
        } catch (InterruptedException e) {
            logger.error("å…³é—­çº¿ç¨‹æ± è¢«ä¸­æ–­", e);
            taskExecutor.getThreadPoolExecutor().shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
    
    /**
     * åŒ…è£…çš„ä»»åŠ¡ç±»ï¼Œæ”¯æŒçŠ¶æ€ç®¡ç†å’Œä¸­æ–­æ£€æŸ¥
     */
    private class ManagedTask implements Runnable {
        private final String taskId;
        private final Runnable task;
        
        public ManagedTask(String taskId, Runnable task) {
            this.taskId = taskId;
            this.task = task;
        }
        
        @Override
        public void run() {
            logger.info("ä»»åŠ¡å¼€å§‹æ‰§è¡Œ: {}", taskId);
            
            try {
                // æ£€æŸ¥æ˜¯å¦è¢«ä¸­æ–­
                if (Thread.currentThread().isInterrupted()) {
                    logger.info("ä»»åŠ¡å¯åŠ¨å‰å·²è¢«ä¸­æ–­: {}", taskId);
                    updateTaskStatus(taskId, TaskStatus.CANCELLED);
                    return;
                }
                
                // æ‰§è¡Œä»»åŠ¡
                task.run();
                
                // ä»»åŠ¡å®Œæˆ
                logger.info("ä»»åŠ¡æ‰§è¡Œå®Œæˆ: {}", taskId);
                updateTaskStatus(taskId, TaskStatus.COMPLETED);
                
            } catch (Exception e) {
                logger.error("ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {}", taskId, e);
                updateTaskStatus(taskId, TaskStatus.FAILED);
                
                TaskInfo taskInfo = taskInfoMap.get(taskId);
                if (taskInfo != null) {
                    taskInfo.setErrorMessage(e.getMessage());
                }
                
            } finally {
                // ä»futuresä¸­ç§»é™¤
                taskFutures.remove(taskId);
            }
        }
    }
    
    /**
     * åŒ…è£…çš„Callableä»»åŠ¡
     */
    private class ManagedCallableTask<T> implements Callable<T> {
        private final String taskId;
        private final Callable<T> task;
        
        public ManagedCallableTask(String taskId, Callable<T> task) {
            this.taskId = taskId;
            this.task = task;
        }
        
        @Override
        public T call() throws Exception {
            logger.info("Callableä»»åŠ¡å¼€å§‹æ‰§è¡Œ: {}", taskId);
            
            try {
                if (Thread.currentThread().isInterrupted()) {
                    logger.info("ä»»åŠ¡å¯åŠ¨å‰å·²è¢«ä¸­æ–­: {}", taskId);
                    updateTaskStatus(taskId, TaskStatus.CANCELLED);
                    return null;
                }
                
                T result = task.call();
                
                logger.info("Callableä»»åŠ¡æ‰§è¡Œå®Œæˆ: {}", taskId);
                updateTaskStatus(taskId, TaskStatus.COMPLETED);
                
                return result;
                
            } catch (Exception e) {
                logger.error("Callableä»»åŠ¡æ‰§è¡Œå¤±è´¥: {}", taskId, e);
                updateTaskStatus(taskId, TaskStatus.FAILED);
                
                TaskInfo taskInfo = taskInfoMap.get(taskId);
                if (taskInfo != null) {
                    taskInfo.setErrorMessage(e.getMessage());
                }
                
                throw e;
                
            } finally {
                taskFutures.remove(taskId);
            }
        }
    }
}


TaskInfo.java(new)
package com.dataloader.task;

/**
 * ä»»åŠ¡ä¿¡æ¯
 */
public class TaskInfo {
    
    private String taskId;
    private TaskStatus status;
    private long startTime;
    private long endTime;
    private String errorMessage;
    
    public TaskInfo(String taskId, TaskStatus status) {
        this.taskId = taskId;
        this.status = status;
        this.startTime = System.currentTimeMillis();
    }
    
    // Getters and Setters
    
    public String getTaskId() {
        return taskId;
    }
    
    public void setTaskId(String taskId) {
        this.taskId = taskId;
    }
    
    public TaskStatus getStatus() {
        return status;
    }
    
    public void setStatus(TaskStatus status) {
        this.status = status;
    }
    
    public long getStartTime() {
        return startTime;
    }
    
    public void setStartTime(long startTime) {
        this.startTime = startTime;
    }
    
    public long getEndTime() {
        return endTime;
    }
    
    public void setEndTime(long endTime) {
        this.endTime = endTime;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
    
    /**
     * è·å–ä»»åŠ¡æ‰§è¡Œæ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰
     */
    public long getDuration() {
        if (endTime > 0) {
            return endTime - startTime;
        }
        return System.currentTimeMillis() - startTime;
    }
    
    @Override
    public String toString() {
        return "TaskInfo{" +
                "taskId='" + taskId + '\'' +
                ", status=" + status +
                ", startTime=" + startTime +
                ", endTime=" + endTime +
                ", duration=" + getDuration() + "ms" +
                ", errorMessage='" + errorMessage + '\'' +
                '}';
    }
}


TaskStatus.java(new)
package com.dataloader.task;

/**
 * ä»»åŠ¡çŠ¶æ€æšä¸¾
 */
public enum TaskStatus {
    
    /** ç­‰å¾…æ‰§è¡Œ */
    PENDING("ç­‰å¾…æ‰§è¡Œ"),
    
    /** æ­£åœ¨è¿è¡Œ */
    RUNNING("æ­£åœ¨è¿è¡Œ"),
    
    /** å·²å®Œæˆ */
    COMPLETED("å·²å®Œæˆ"),
    
    /** å·²å–æ¶ˆ */
    CANCELLED("å·²å–æ¶ˆ"),
    
    /** æ‰§è¡Œå¤±è´¥ */
    FAILED("æ‰§è¡Œå¤±è´¥"),
    
    /** æœªæ‰¾åˆ° */
    NOT_FOUND("æœªæ‰¾åˆ°");
    
    private final String description;
    
    TaskStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
ThreadPoolStatus.java(new)
package com.dataloader.task;

/**
 * çº¿ç¨‹æ± çŠ¶æ€ä¿¡æ¯
 */
public class ThreadPoolStatus {
    
    /** å½“å‰çº¿ç¨‹æ± å¤§å° */
    private int poolSize;
    
    /** æ´»è·ƒçº¿ç¨‹æ•° */
    private int activeCount;
    
    /** å·²å®Œæˆä»»åŠ¡æ•° */
    private long completedTaskCount;
    
    /** æ€»ä»»åŠ¡æ•° */
    private long taskCount;
    
    /** é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡æ•° */
    private int queueSize;
    
    public ThreadPoolStatus(int poolSize, int activeCount, long completedTaskCount, 
                           long taskCount, int queueSize) {
        this.poolSize = poolSize;
        this.activeCount = activeCount;
        this.completedTaskCount = completedTaskCount;
        this.taskCount = taskCount;
        this.queueSize = queueSize;
    }
    
    // Getters
    
    public int getPoolSize() {
        return poolSize;
    }
    
    public int getActiveCount() {
        return activeCount;
    }
    
    public long getCompletedTaskCount() {
        return completedTaskCount;
    }
    
    public long getTaskCount() {
        return taskCount;
    }
    
    public int getQueueSize() {
        return queueSize;
    }
    
    /**
     * è·å–ç©ºé—²çº¿ç¨‹æ•°
     */
    public int getIdleCount() {
        return poolSize - activeCount;
    }
    
    /**
     * è·å–æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡æ•°ï¼ˆæ´»è·ƒ+é˜Ÿåˆ—ï¼‰
     */
    public int getRunningTaskCount() {
        return activeCount + queueSize;
    }
    
    @Override
    public String toString() {
        return "ThreadPoolStatus{" +
                "poolSize=" + poolSize +
                ", activeCount=" + activeCount +
                ", idleCount=" + getIdleCount() +
                ", completedTaskCount=" + completedTaskCount +
                ", taskCount=" + taskCount +
                ", queueSize=" + queueSize +
                '}';
    }
}


TaskManagerExample.java(new)
+219
ç°åœ¨è®©æˆ‘åˆ›å»ºä¸€ä¸ªRESTæ§åˆ¶å™¨ç¤ºä¾‹ï¼Œå±•ç¤ºå¦‚ä½•åœ¨Web APIä¸­ä½¿ç”¨ä»»åŠ¡ç®¡ç†å™¨ï¼š
TaskController.java(new)
package com.dataloader.controller;

import com.dataloader.task.TaskInfo;
import com.dataloader.task.TaskManager;
import com.dataloader.task.TaskStatus;
import com.dataloader.task.ThreadPoolStatus;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

/**
 * ä»»åŠ¡ç®¡ç†æ§åˆ¶å™¨
 * æä¾›ä»»åŠ¡çš„å¯åŠ¨ã€åœæ­¢ã€æŸ¥è¯¢ç­‰REST API
 */
@RestController
@RequestMapping("/api/tasks")
public class TaskController {
    
    private static final Logger logger = LoggerFactory.getLogger(TaskController.class);
    
    @Autowired
    private TaskManager taskManager;
    
    /**
     * å¯åŠ¨ä¸€ä¸ªETLä»»åŠ¡
     * POST /api/tasks/start?taskId=xxx&pipelineCode=xxx
     */
    @PostMapping("/start")
    public Map<String, Object> startTask(
            @RequestParam String taskId,
            @RequestParam String pipelineCode) {
        
        logger.info("æ¥æ”¶å¯åŠ¨ä»»åŠ¡è¯·æ±‚: taskId={}, pipelineCode={}", taskId, pipelineCode);
        
        Map<String, Object> response = new HashMap<>();
        
        try {
            // åˆ›å»ºETLä»»åŠ¡
            Runnable etlTask = createEtlTask(pipelineCode);
            
            // æäº¤ä»»åŠ¡
            boolean success = taskManager.submitTask(taskId, etlTask);
            
            if (success) {
                response.put("success", true);
                response.put("message", "ä»»åŠ¡å¯åŠ¨æˆåŠŸ");
                response.put("taskId", taskId);
                response.put("status", TaskStatus.RUNNING);
            } else {
                response.put("success", false);
                response.put("message", "ä»»åŠ¡å¯åŠ¨å¤±è´¥ï¼Œå¯èƒ½ä»»åŠ¡å·²å­˜åœ¨");
            }
            
        } catch (Exception e) {
            logger.error("å¯åŠ¨ä»»åŠ¡å¤±è´¥", e);
            response.put("success", false);
            response.put("message", "å¯åŠ¨ä»»åŠ¡å¼‚å¸¸: " + e.getMessage());
        }
        
        return response;
    }
    
    /**
     * åœæ­¢ä¸€ä¸ªä»»åŠ¡
     * POST /api/tasks/stop?taskId=xxx&interrupt=true
     */
    @PostMapping("/stop")
    public Map<String, Object> stopTask(
            @RequestParam String taskId,
            @RequestParam(defaultValue = "true") boolean interrupt) {
        
        logger.info("æ¥æ”¶åœæ­¢ä»»åŠ¡è¯·æ±‚: taskId={}, interrupt={}", taskId, interrupt);
        
        Map<String, Object> response = new HashMap<>();
        
        try {
            boolean success = taskManager.stopTask(taskId, interrupt);
            
            if (success) {
                response.put("success", true);
                response.put("message", "ä»»åŠ¡åœæ­¢æˆåŠŸ");
                response.put("taskId", taskId);
            } else {
                response.put("success", false);
                response.put("message", "ä»»åŠ¡åœæ­¢å¤±è´¥ï¼Œå¯èƒ½ä»»åŠ¡ä¸å­˜åœ¨æˆ–å·²å®Œæˆ");
            }
            
        } catch (Exception e) {
            logger.error("åœæ­¢ä»»åŠ¡å¤±è´¥", e);
            response.put("success", false);
            response.put("message", "åœæ­¢ä»»åŠ¡å¼‚å¸¸: " + e.getMessage());
        }
        
        return response;
    }
    
    /**
     * åœæ­¢æ‰€æœ‰ä»»åŠ¡
     * POST /api/tasks/stopAll?interrupt=true
     */
    @PostMapping("/stopAll")
    public Map<String, Object> stopAllTasks(
            @RequestParam(defaultValue = "true") boolean interrupt) {
        
        logger.info("æ¥æ”¶åœæ­¢æ‰€æœ‰ä»»åŠ¡è¯·æ±‚: interrupt={}", interrupt);
        
        Map<String, Object> response = new HashMap<>();
        
        try {
            taskManager.stopAllTasks(interrupt);
            
            response.put("success", true);
            response.put("message", "æ‰€æœ‰ä»»åŠ¡å·²åœæ­¢");
            
        } catch (Exception e) {
            logger.error("åœæ­¢æ‰€æœ‰ä»»åŠ¡å¤±è´¥", e);
            response.put("success", false);
            response.put("message", "åœæ­¢æ‰€æœ‰ä»»åŠ¡å¼‚å¸¸: " + e.getMessage());
        }
        
        return response;
    }
    
    /**
     * æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
     * GET /api/tasks/status?taskId=xxx
     */
    @GetMapping("/status")
    public Map<String, Object> getTaskStatus(@RequestParam String taskId) {
        
        logger.info("æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€: taskId={}", taskId);
        
        Map<String, Object> response = new HashMap<>();
        
        TaskStatus status = taskManager.getTaskStatus(taskId);
        
        if (status == TaskStatus.NOT_FOUND) {
            response.put("success", false);
            response.put("message", "ä»»åŠ¡ä¸å­˜åœ¨");
        } else {
            response.put("success", true);
            response.put("taskId", taskId);
            response.put("status", status);
            response.put("statusDescription", status.getDescription());
        }
        
        return response;
    }
    
    /**
     * æŸ¥è¯¢ä»»åŠ¡è¯¦ç»†ä¿¡æ¯
     * GET /api/tasks/info?taskId=xxx
     */
    @GetMapping("/info")
    public Map<String, Object> getTaskInfo(@RequestParam String taskId) {
        
        logger.info("æŸ¥è¯¢ä»»åŠ¡è¯¦ç»†ä¿¡æ¯: taskId={}", taskId);
        
        Map<String, Object> response = new HashMap<>();
        
        TaskInfo taskInfo = taskManager.getTaskInfo(taskId);
        
        if (taskInfo == null) {
            response.put("success", false);
            response.put("message", "ä»»åŠ¡ä¸å­˜åœ¨");
        } else {
            response.put("success", true);
            response.put("taskInfo", taskInfo);
        }
        
        return response;
    }
    
    /**
     * æŸ¥è¯¢æ‰€æœ‰ä»»åŠ¡
     * GET /api/tasks/all
     */
    @GetMapping("/all")
    public Map<String, Object> getAllTasks() {
        
        logger.info("æŸ¥è¯¢æ‰€æœ‰ä»»åŠ¡");
        
        Map<String, Object> response = new HashMap<>();
        
        Map<String, TaskInfo> allTasks = taskManager.getAllTaskInfo();
        
        response.put("success", true);
        response.put("taskCount", allTasks.size());
        response.put("tasks", allTasks);
        
        return response;
    }
    
    /**
     * æŸ¥è¯¢çº¿ç¨‹æ± çŠ¶æ€
     * GET /api/tasks/pool-status
     */
    @GetMapping("/pool-status")
    public Map<String, Object> getPoolStatus() {
        
        logger.info("æŸ¥è¯¢çº¿ç¨‹æ± çŠ¶æ€");
        
        Map<String, Object> response = new HashMap<>();
        
        ThreadPoolStatus poolStatus = taskManager.getThreadPoolStatus();
        
        response.put("success", true);
        response.put("poolStatus", poolStatus);
        
        return response;
    }
    
    /**
     * æ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡
     * POST /api/tasks/cleanup
     */
    @PostMapping("/cleanup")
    public Map<String, Object> cleanupCompletedTasks() {
        
        logger.info("æ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡");
        
        Map<String, Object> response = new HashMap<>();
        
        try {
            int beforeCount = taskManager.getAllTaskInfo().size();
            taskManager.cleanupCompletedTasks();
            int afterCount = taskManager.getAllTaskInfo().size();
            
            response.put("success", true);
            response.put("message", "æ¸…ç†å®Œæˆ");
            response.put("cleanedCount", beforeCount - afterCount);
            response.put("remainingCount", afterCount);
            
        } catch (Exception e) {
            logger.error("æ¸…ç†ä»»åŠ¡å¤±è´¥", e);
            response.put("success", false);
            response.put("message", "æ¸…ç†ä»»åŠ¡å¼‚å¸¸: " + e.getMessage());
        }
        
        return response;
    }
    
    /**
     * åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„ETLä»»åŠ¡
     */
    private Runnable createEtlTask(String pipelineCode) {
        return () -> {
            logger.info("[{}] ETLä»»åŠ¡å¼€å§‹æ‰§è¡Œ", pipelineCode);
            
            try {
                // é˜¶æ®µ1: æ•°æ®æŠ½å–
                logger.info("[{}] é˜¶æ®µ1: æ•°æ®æŠ½å–...", pipelineCode);
                for (int i = 0; i < 5; i++) {
                    if (Thread.currentThread().isInterrupted()) {
                        logger.info("[{}] æ•°æ®æŠ½å–è¢«ä¸­æ–­", pipelineCode);
                        return;
                    }
                    Thread.sleep(1000);
                    logger.info("[{}] æ•°æ®æŠ½å–è¿›åº¦: {}%", pipelineCode, (i + 1) * 20);
                }
                logger.info("[{}] æ•°æ®æŠ½å–å®Œæˆ", pipelineCode);
                
                // é˜¶æ®µ2: æ•°æ®è½¬æ¢
                logger.info("[{}] é˜¶æ®µ2: æ•°æ®è½¬æ¢...", pipelineCode);
                for (int i = 0; i < 5; i++) {
                    if (Thread.currentThread().isInterrupted()) {
                        logger.info("[{}] æ•°æ®è½¬æ¢è¢«ä¸­æ–­", pipelineCode);
                        return;
                    }
                    Thread.sleep(1000);
                    logger.info("[{}] æ•°æ®è½¬æ¢è¿›åº¦: {}%", pipelineCode, (i + 1) * 20);
                }
                logger.info("[{}] æ•°æ®è½¬æ¢å®Œæˆ", pipelineCode);
                
                // é˜¶æ®µ3: æ•°æ®åŠ è½½
                logger.info("[{}] é˜¶æ®µ3: æ•°æ®åŠ è½½...", pipelineCode);
                for (int i = 0; i < 5; i++) {
                    if (Thread.currentThread().isInterrupted()) {
                        logger.info("[{}] æ•°æ®åŠ è½½è¢«ä¸­æ–­", pipelineCode);
                        return;
                    }
                    Thread.sleep(1000);
                    logger.info("[{}] æ•°æ®åŠ è½½è¿›åº¦: {}%", pipelineCode, (i + 1) * 20);
                }
                logger.info("[{}] æ•°æ®åŠ è½½å®Œæˆ", pipelineCode);
                
                logger.info("[{}] ETLä»»åŠ¡æ‰§è¡Œå®Œæˆ", pipelineCode);
                
            } catch (InterruptedException e) {
                logger.info("[{}] ETLä»»åŠ¡è¢«ä¸­æ–­", pipelineCode);
                Thread.currentThread().interrupt();
            } catch (Exception e) {
                logger.error("[{}] ETLä»»åŠ¡æ‰§è¡Œå¤±è´¥", pipelineCode, e);
                throw new RuntimeException("ETLä»»åŠ¡æ‰§è¡Œå¤±è´¥", e);
            }
        };
    }
}


README.md(new)
# ThreadPoolTaskExecutor ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ

## ğŸ“‹ æ¦‚è¿°

è¿™æ˜¯ä¸€ä¸ªå®Œæ•´çš„ `ThreadPoolTaskExecutor` ä»»åŠ¡ç®¡ç†è§£å†³æ–¹æ¡ˆï¼Œæä¾›äº†ä»»åŠ¡çš„å¯åŠ¨ã€åœæ­¢ã€ç›‘æ§ç­‰åŠŸèƒ½ã€‚

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½

### 1. ä»»åŠ¡æäº¤ä¸ç®¡ç†
- âœ… æäº¤ Runnable ä»»åŠ¡
- âœ… æäº¤ Callable ä»»åŠ¡ï¼ˆå¸¦è¿”å›å€¼ï¼‰
- âœ… ä»»åŠ¡å”¯ä¸€æ ‡è¯†ï¼ˆtaskIdï¼‰
- âœ… ä»»åŠ¡çŠ¶æ€è·Ÿè¸ª

### 2. ä»»åŠ¡æ§åˆ¶
- âœ… åœæ­¢æŒ‡å®šä»»åŠ¡
- âœ… åœæ­¢æ‰€æœ‰ä»»åŠ¡
- âœ… å¯ä¸­æ–­/ä¸å¯ä¸­æ–­åœæ­¢
- âœ… ä¼˜é›…å…³é—­çº¿ç¨‹æ± 

### 3. çŠ¶æ€ç›‘æ§
- âœ… æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
- âœ… æŸ¥è¯¢ä»»åŠ¡è¯¦ç»†ä¿¡æ¯
- âœ… æŸ¥è¯¢æ‰€æœ‰ä»»åŠ¡
- âœ… æŸ¥è¯¢çº¿ç¨‹æ± çŠ¶æ€
- âœ… æ¸…ç†å·²å®Œæˆä»»åŠ¡

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ ¸å¿ƒç±»

1. **TaskManager** - ä»»åŠ¡ç®¡ç†å™¨
   - ç®¡ç† ThreadPoolTaskExecutor
   - ç»´æŠ¤ä»»åŠ¡ Future æ˜ å°„
   - æä¾›ä»»åŠ¡æ“ä½œæ¥å£

2. **TaskInfo** - ä»»åŠ¡ä¿¡æ¯
   - ä»»åŠ¡ID
   - ä»»åŠ¡çŠ¶æ€
   - å¼€å§‹/ç»“æŸæ—¶é—´
   - é”™è¯¯ä¿¡æ¯

3. **TaskStatus** - ä»»åŠ¡çŠ¶æ€æšä¸¾
   - PENDING - ç­‰å¾…æ‰§è¡Œ
   - RUNNING - æ­£åœ¨è¿è¡Œ
   - COMPLETED - å·²å®Œæˆ
   - CANCELLED - å·²å–æ¶ˆ
   - FAILED - æ‰§è¡Œå¤±è´¥

4. **ThreadPoolStatus** - çº¿ç¨‹æ± çŠ¶æ€
   - çº¿ç¨‹æ± å¤§å°
   - æ´»è·ƒçº¿ç¨‹æ•°
   - å·²å®Œæˆä»»åŠ¡æ•°
   - é˜Ÿåˆ—å¤§å°

## ğŸ’¡ ä½¿ç”¨æ–¹æ³•

### åŸºç¡€ç”¨æ³•

#### 1. æäº¤ç®€å•ä»»åŠ¡

```java
@Autowired
private TaskManager taskManager;

// æäº¤ä»»åŠ¡
taskManager.submitTask("task-001", () -> {
    System.out.println("æ‰§è¡Œä»»åŠ¡...");
    // ä»»åŠ¡é€»è¾‘
});
```

#### 2. æäº¤å¯ä¸­æ–­çš„ä»»åŠ¡

```java
taskManager.submitTask("task-002", () -> {
    for (int i = 0; i < 100; i++) {
        // æ£€æŸ¥ä¸­æ–­æ ‡å¿—
        if (Thread.currentThread().isInterrupted()) {
            System.out.println("ä»»åŠ¡è¢«ä¸­æ–­ï¼Œæå‰é€€å‡º");
            return;
        }
        
        // æ‰§è¡Œä»»åŠ¡
        processData(i);
        
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            // æ¢å¤ä¸­æ–­çŠ¶æ€
            Thread.currentThread().interrupt();
            return;
        }
    }
});
```

#### 3. æäº¤ Callable ä»»åŠ¡ï¼ˆå¸¦è¿”å›å€¼ï¼‰

```java
Future<String> future = taskManager.submitTask("task-003", () -> {
    // æ‰§è¡Œä»»åŠ¡
    String result = performCalculation();
    return result;
});

// è·å–ç»“æœ
try {
    String result = future.get(); // é˜»å¡ç­‰å¾…
    System.out.println("ä»»åŠ¡ç»“æœ: " + result);
} catch (Exception e) {
    e.printStackTrace();
}
```

#### 4. åœæ­¢ä»»åŠ¡

```java
// åœæ­¢ä»»åŠ¡ï¼ˆä¸­æ–­ï¼‰
taskManager.stopTask("task-001", true);

// åœæ­¢ä»»åŠ¡ï¼ˆä¸ä¸­æ–­ï¼Œç­‰å¾…å½“å‰æ“ä½œå®Œæˆï¼‰
taskManager.stopTask("task-001", false);

// åœæ­¢æ‰€æœ‰ä»»åŠ¡
taskManager.stopAllTasks(true);
```

#### 5. æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€

```java
// è·å–ä»»åŠ¡çŠ¶æ€
TaskStatus status = taskManager.getTaskStatus("task-001");
System.out.println("ä»»åŠ¡çŠ¶æ€: " + status);

// è·å–ä»»åŠ¡è¯¦ç»†ä¿¡æ¯
TaskInfo info = taskManager.getTaskInfo("task-001");
System.out.println("ä»»åŠ¡ä¿¡æ¯: " + info);

// è·å–æ‰€æœ‰ä»»åŠ¡
Map<String, TaskInfo> allTasks = taskManager.getAllTaskInfo();
allTasks.forEach((id, task) -> {
    System.out.println(id + " -> " + task.getStatus());
});
```

#### 6. æŸ¥è¯¢çº¿ç¨‹æ± çŠ¶æ€

```java
ThreadPoolStatus poolStatus = taskManager.getThreadPoolStatus();
System.out.println("çº¿ç¨‹æ± å¤§å°: " + poolStatus.getPoolSize());
System.out.println("æ´»è·ƒçº¿ç¨‹: " + poolStatus.getActiveCount());
System.out.println("é˜Ÿåˆ—ä»»åŠ¡: " + poolStatus.getQueueSize());
```

### REST API ä½¿ç”¨

å¦‚æœé›†æˆäº† `TaskController`ï¼Œå¯ä»¥é€šè¿‡ HTTP API ç®¡ç†ä»»åŠ¡ï¼š

#### å¯åŠ¨ä»»åŠ¡
```bash
POST /api/tasks/start?taskId=task-001&pipelineCode=PIPELINE_001
```

#### åœæ­¢ä»»åŠ¡
```bash
POST /api/tasks/stop?taskId=task-001&interrupt=true
```

#### æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
```bash
GET /api/tasks/status?taskId=task-001
```

#### æŸ¥è¯¢æ‰€æœ‰ä»»åŠ¡
```bash
GET /api/tasks/all
```

#### æŸ¥è¯¢çº¿ç¨‹æ± çŠ¶æ€
```bash
GET /api/tasks/pool-status
```

## ğŸ”§ é…ç½®è¯´æ˜

### çº¿ç¨‹æ± å‚æ•°

åœ¨ `TaskManager` ä¸­å¯ä»¥é…ç½®ä»¥ä¸‹å‚æ•°ï¼š

```java
executor.setCorePoolSize(5);              // æ ¸å¿ƒçº¿ç¨‹æ•°
executor.setMaxPoolSize(10);              // æœ€å¤§çº¿ç¨‹æ•°
executor.setQueueCapacity(100);           // é˜Ÿåˆ—å®¹é‡
executor.setKeepAliveSeconds(60);         // çº¿ç¨‹ç©ºé—²æ—¶é—´
executor.setThreadNamePrefix("ETL-Task-"); // çº¿ç¨‹åç§°å‰ç¼€
```

### æ‹’ç»ç­–ç•¥

æ”¯æŒä»¥ä¸‹æ‹’ç»ç­–ç•¥ï¼š

1. **CallerRunsPolicy** - ç”±è°ƒç”¨çº¿ç¨‹æ‰§è¡Œï¼ˆé»˜è®¤ï¼‰
2. **AbortPolicy** - æŠ›å‡ºå¼‚å¸¸
3. **DiscardPolicy** - ä¸¢å¼ƒä»»åŠ¡
4. **DiscardOldestPolicy** - ä¸¢å¼ƒæœ€æ—§çš„ä»»åŠ¡

```java
executor.setRejectedExecutionHandler(
    new ThreadPoolExecutor.CallerRunsPolicy()
);
```

## âš ï¸ æœ€ä½³å®è·µ

### 1. ä»»åŠ¡è®¾è®¡

**âœ… æ­£ç¡®çš„åšæ³•ï¼š**

```java
taskManager.submitTask("task-001", () -> {
    for (int i = 0; i < 1000; i++) {
        // å®šæœŸæ£€æŸ¥ä¸­æ–­æ ‡å¿—
        if (Thread.currentThread().isInterrupted()) {
            cleanup();
            return;
        }
        
        processItem(i);
        
        // å¯ä¸­æ–­çš„ç­‰å¾…
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            cleanup();
            return;
        }
    }
});
```

**âŒ é”™è¯¯çš„åšæ³•ï¼š**

```java
taskManager.submitTask("task-001", () -> {
    // ä»ä¸æ£€æŸ¥ä¸­æ–­æ ‡å¿—
    for (int i = 0; i < 1000; i++) {
        processItem(i);
        // æ— æ³•ä¸­æ–­ï¼
    }
});
```

### 2. å¼‚å¸¸å¤„ç†

**âœ… æ­£ç¡®çš„åšæ³•ï¼š**

```java
taskManager.submitTask("task-001", () -> {
    try {
        performTask();
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt(); // æ¢å¤ä¸­æ–­çŠ¶æ€
        cleanup();
    } catch (Exception e) {
        logger.error("ä»»åŠ¡æ‰§è¡Œå¤±è´¥", e);
        // é€‚å½“çš„é”™è¯¯å¤„ç†
    }
});
```

### 3. èµ„æºæ¸…ç†

```java
taskManager.submitTask("task-001", () -> {
    Connection conn = null;
    try {
        conn = getConnection();
        processData(conn);
    } finally {
        // ç¡®ä¿èµ„æºè¢«é‡Šæ”¾
        if (conn != null) {
            conn.close();
        }
    }
});
```

### 4. çº¿ç¨‹æ± å¤§å°è®¾ç½®

- **CPU å¯†é›†å‹ä»»åŠ¡**: `çº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° + 1`
- **IO å¯†é›†å‹ä»»åŠ¡**: `çº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° * 2 æˆ–æ›´å¤š`
- **æ··åˆå‹ä»»åŠ¡**: æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´

```java
// è·å–CPUæ ¸å¿ƒæ•°
int processors = Runtime.getRuntime().availableProcessors();

// CPUå¯†é›†å‹
executor.setCorePoolSize(processors + 1);

// IOå¯†é›†å‹
executor.setCorePoolSize(processors * 2);
```

## ğŸ“Š ç›‘æ§å»ºè®®

### 1. å®šæœŸæ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€

```java
@Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
public void monitorThreadPool() {
    ThreadPoolStatus status = taskManager.getThreadPoolStatus();
    
    logger.info("çº¿ç¨‹æ± ç›‘æ§ - " +
        "æ± å¤§å°: {}, æ´»è·ƒ: {}, é˜Ÿåˆ—: {}, å®Œæˆ: {}",
        status.getPoolSize(),
        status.getActiveCount(),
        status.getQueueSize(),
        status.getCompletedTaskCount()
    );
    
    // å‘Šè­¦é€»è¾‘
    if (status.getQueueSize() > 80) {
        logger.warn("é˜Ÿåˆ—ä»»åŠ¡è¿‡å¤šï¼Œå¯èƒ½éœ€è¦æ‰©å®¹");
    }
}
```

### 2. æ¸…ç†å·²å®Œæˆä»»åŠ¡

```java
@Scheduled(cron = "0 0 * * * *") // æ¯å°æ—¶æ‰§è¡Œ
public void cleanupTasks() {
    taskManager.cleanupCompletedTasks();
    logger.info("å·²æ¸…ç†å®Œæˆçš„ä»»åŠ¡");
}
```

## ğŸš€ ETL åœºæ™¯åº”ç”¨ç¤ºä¾‹

### ç®¡é“ä»»åŠ¡æ‰§è¡Œ

```java
public void executePipeline(String pipelineCode) {
    String taskId = "pipeline-" + pipelineCode;
    
    taskManager.submitTask(taskId, () -> {
        try {
            // 1. æŠ½å–é˜¶æ®µ
            if (Thread.currentThread().isInterrupted()) return;
            List<Map> extractedData = extractData(pipelineCode);
            logger.info("[{}] æŠ½å–å®Œæˆ: {} æ¡", pipelineCode, extractedData.size());
            
            // 2. è½¬æ¢é˜¶æ®µ
            if (Thread.currentThread().isInterrupted()) return;
            List<Map> transformedData = transformData(extractedData);
            logger.info("[{}] è½¬æ¢å®Œæˆ", pipelineCode);
            
            // 3. åŠ è½½é˜¶æ®µ
            if (Thread.currentThread().isInterrupted()) return;
            loadData(transformedData);
            logger.info("[{}] åŠ è½½å®Œæˆ", pipelineCode);
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.info("[{}] ç®¡é“è¢«ä¸­æ–­", pipelineCode);
        } catch (Exception e) {
            logger.error("[{}] ç®¡é“æ‰§è¡Œå¤±è´¥", pipelineCode, e);
            throw new RuntimeException(e);
        }
    });
}

// åœæ­¢ç®¡é“
public void stopPipeline(String pipelineCode) {
    String taskId = "pipeline-" + pipelineCode;
    taskManager.stopTask(taskId, true);
}
```

## ğŸ” æ•…éšœæ’æŸ¥

### ä»»åŠ¡æ— æ³•åœæ­¢

**åŸå› **: ä»»åŠ¡æ²¡æœ‰æ£€æŸ¥ä¸­æ–­æ ‡å¿—

**è§£å†³**: åœ¨ä»»åŠ¡ä¸­å®šæœŸæ£€æŸ¥ `Thread.currentThread().isInterrupted()`

### çº¿ç¨‹æ± é˜Ÿåˆ—æ»¡

**åŸå› **: ä»»åŠ¡æäº¤é€Ÿåº¦ > å¤„ç†é€Ÿåº¦

**è§£å†³**: 
1. å¢åŠ çº¿ç¨‹æ•°
2. å¢åŠ é˜Ÿåˆ—å®¹é‡
3. ä¼˜åŒ–ä»»åŠ¡æ‰§è¡Œæ•ˆç‡
4. ä½¿ç”¨åˆé€‚çš„æ‹’ç»ç­–ç•¥

### ä»»åŠ¡æ‰§è¡Œæ—¶é—´è¿‡é•¿

**åŸå› **: ä»»åŠ¡é€»è¾‘å¤æ‚æˆ–èµ„æºç«äº‰

**è§£å†³**:
1. ä¼˜åŒ–ä»»åŠ¡é€»è¾‘
2. åˆ†è§£å¤§ä»»åŠ¡ä¸ºå°ä»»åŠ¡
3. æ£€æŸ¥æ˜¯å¦æœ‰æ­»é”æˆ–èµ„æºé˜»å¡

## ğŸ“š å‚è€ƒç¤ºä¾‹

å®Œæ•´çš„ä½¿ç”¨ç¤ºä¾‹è¯·å‚è€ƒ:
- `TaskManagerExample.java` - åŸºç¡€ä½¿ç”¨ç¤ºä¾‹
- `TaskController.java` - REST API ç¤ºä¾‹

## ğŸ™‹ å¸¸è§é—®é¢˜

**Q: å¦‚ä½•ç¡®ä¿ä»»åŠ¡å¯ä»¥è¢«ä¸­æ–­ï¼Ÿ**

A: åœ¨ä»»åŠ¡ä¸­å®šæœŸæ£€æŸ¥ä¸­æ–­æ ‡å¿—ï¼Œå¹¶åœ¨æ•è· InterruptedException åæ¢å¤ä¸­æ–­çŠ¶æ€ã€‚

**Q: Future.cancel() å’Œ stopTask() çš„åŒºåˆ«ï¼Ÿ**

A: `stopTask()` å†…éƒ¨è°ƒç”¨ `Future.cancel()`ï¼Œä½†åŒæ—¶ä¼šæ›´æ–°ä»»åŠ¡çŠ¶æ€å’Œæ¸…ç†èµ„æºã€‚

**Q: å¦‚ä½•è·å–ä»»åŠ¡çš„è¿”å›å€¼ï¼Ÿ**

A: ä½¿ç”¨ `submitTask(taskId, Callable)` æäº¤ä»»åŠ¡ï¼Œè¿”å›çš„ Future å¯ä»¥è·å–ç»“æœã€‚

**Q: çº¿ç¨‹æ± å…³é—­åè¿˜èƒ½æäº¤ä»»åŠ¡å—ï¼Ÿ**

A: ä¸èƒ½ã€‚å…³é—­åæäº¤ä»»åŠ¡ä¼šæŠ›å‡º RejectedExecutionExceptionã€‚

